#!/bin/bash

OPTIND=1 # Reset in case getopts has been used previously in the shell.

output_file="asset-hashes.go"

while getopts "h?o:" opt; do
	case "$opt" in
	h|\?)
		printf "Usage: %s [-o <output file>] <files>\n" $0
		exit 0
		;;
	o)
		output_file=$OPTARG
		;;
	esac
done

shift $((OPTIND-1))

(
cat << EOF
// Code generated by asset-hashes.
// sources:
EOF

for file in $(echo $@); do
	printf "// %s\n" "${file}"
done

cat << EOF
// DO NOT EDIT!

package main

import (
	"fmt"
	"os"
)

const _assetHashLength = 64

var _assetHashes = map[string]string{
EOF

sha256sum $@ | awk '{print "\t\"" $2 "\": \"" $1 "\","}'

cat << EOF
}

func AssetHash(name string) (string, error) {
	if hash, ok := _assetHashes[name]; ok {
		return hash, nil
	}

	return "", fmt.Errorf("Asset %s not found", name)
}

func AssetHashName(name string) (string, error) {
	hash, err := AssetHash(name)
	if err != nil {
		return "", err
	}

	for i := len(name) - 1; i >= 0 && !os.IsPathSeparator(name[i]); i-- {
		if name[i] == '.' {
			return name[:i] + "-" + hash + name[i:], nil
		}
	}

	return name + "-" + hash, nil
}

func AssetNameStripHash(name string) (string, error) {
	for i := len(name) - 1; i >= 0 && !os.IsPathSeparator(name[i]); i-- {
		if name[i] != '.' {
			continue
		}

		if i-_assetHashLength-1 < 0 || name[i-_assetHashLength-1] != '-' {
			return "", fmt.Errorf("Asset %s not found", name)
		}

		hash, err := AssetHash(name[:i-_assetHashLength-1] + name[i:])
		if err != nil {
			return "", err
		}

		if name[i-_assetHashLength:i] != hash {
			return "", fmt.Errorf("Asset %s not found", name)
		}

		return name[:i-_assetHashLength-1] + name[i:], nil
	}

	i := len(name)

	if i-_assetHashLength-1 < 0 || name[i-_assetHashLength-1] != '-' {
		return "", fmt.Errorf("Asset %s not found", name)
	}

	hash, err := AssetHash(name[:i-_assetHashLength-1] + name[i:])
	if err != nil {
		return "", err
	}

	if name[i-_assetHashLength:i] != hash {
		return "", fmt.Errorf("Asset %s not found", name)
	}

	return name[:i-_assetHashLength-1] + name[i:], nil
}

func AssetFromNameHash(name string) ([]byte, error) {
	name, err := AssetNameStripHash(name)
	if err != nil {
		return nil, err
	}

	return Asset(name)
}

func AssetInfoFromNameHash(name string) (os.FileInfo, error) {
	name, err := AssetNameStripHash(name)
	if err != nil {
		return nil, err
	}

	return AssetInfo(name)
}
EOF
) | gofmt > $output_file
